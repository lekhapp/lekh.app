{"pageProps":{"slug":"webassembly","contentHtml":"\nWebAssembly (or wasm) is a portable binary format for executable programs, and a corresponding textual assembly language. The main goal of WebAssembly is to enable high-performance applications on web pages. Languages such as C, C++, Rust etc can be compiled into web assembly and can be executed in a browser environment.\n\nWe are compiling our [Lekh Board](/) C++ code into wasm and running in the browser. [Lekh Board](/) is an intelligent collaborative whiteboard app. We released the Lekh Board a while ago and in this blog post I am sharing the experience of using the web assembly in Lekh Board.\n\nI am going to explain our use case first then will explain why we use the web assembly. Then performance comparison of native code to web assembly running on Firefox and Google Chrome.\n\n&nbsp;\n\n## Intro to Lekh Board and high level architecture\n\nLekh Board is a whiteboard app with the intelligence of recognizing userâ€™s rough drawings and converting them into shapes and connection lines. It recognizes all basic shapes which you typically draw in a typical whiteboard discussion. Here is a domo of the shape recognition capability of Lekh Board.\n\n![Shape Recognition](/assets/blogs/introduction/drawings.gif \"Lekh App Shape Recognition\")\n\n&nbsp;\n\nLekh Board is built with the [Lekh Diagram](/diagram.html) code base. I was doing the Lekh Diagram (iOS and Android) as a hobby app for quite some time and sometime ago I decided to build a collaborative version of it called Lekh Board. The core logic of Lekh Diagram is written in C++ with only dependency on the standard C++ library. \n\nThe iOS app UI is written in Object C and consumes the C++ code directly in Object C project.\nThe Android UI is written in Java and consumes the C++ code via JNI.\n\nThis can be explained with the following diagram:\n\n![Architecture](/assets/blogs/webasm/arch.png \"Lekh App Architecture\")\n\nThe Lekh Core does not have any platform specific code. It only uses the standard C++ library. This makes it a perfect candidate for getting converted in web assembly without any issues.\n\n&nbsp;\n\n## Using web assembly to build Lekh Board\nTo run the Lekh Core logic in browsers we had these choices:\n- Rewrite the Lekh Core in Javascript\n- Use web assembly or asm.js to make use of the C++ code into browser\n\nWe did not want to rewrite so the only option we had was to use web assembly (or asm.js). But then we had these concerns:\n- What is the binary size that users have to download for loading the app in browsers?\n- Will the performance be acceptable?\n- Browser support\n\nOur initial exercise was to address these concerns before taking the decision to use the web assembly.  In our initial experiment, we got around 5M of the wasm file and performance was all good. Also we could run the web assembly in Firefox, Chrome and Safari. After these observations, we were pretty sure that we could use the web assembly.\n\n&nbsp;\n\nNow our architecture becomes like this\n\n![Architecture](/assets/blogs/webasm/arch-2.png \"Lekh App Architecture\")\n\n&nbsp; \n\nThe Lekh Board uses HTML canvas for drawings. The glue code has logic to call the HTML canvas API. The glue code also exposes some of the C++ code into javascript using [embind](https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html).\n\n&nbsp; \n\n## Debugging \nThe Google Chrome team put out a [blog post](https://developer.chrome.com/blog/wasm-debugging-2020/) describing how to debug the web assembly in Google Chrome. Unfortunately, I was not able to get it working. The example there is for a very simple C++ code. In our case, we have a mix of C++ and C Code. Actually, we have written our code only in C++ but we also embed [Lua](https://www.lua.org/) which is written in C. We compile separately and produce bit code and then use emcc again to link them together. I followed the instructions given by the Chrome team, but that did not work.\n\nSo for the debugging the only thing that we could do was to use console.log() from the glue code. \n\n&nbsp; \n\n## Performance:\nHere is a simple shape recognition benchmark. In this benchmark, I am calling shape recognizer 1000 times for same set of points which are recognized as a circle.\n\nHere is pseudo code for the benchmark\n\n    void benchmark() {\n      auto rawPoints = getPointsForCircle();\n      auto t1 = get_cur_time();\n      for (int i = 0; i < 1000; i++) {\n        Recognizer recognizer;\n        recognizer.recognize(&rawPoints);\n      }\n     auto t2 = get_cur_time();\n     cout << t2 - t1;\n    }\n\n\n&nbsp;\n\nThe shape recognition algorithm is single threaded only. Also there is no IO or any syscall so it is purely CPU intensive task.\n\nThe benchmark code was run on OS X as native binary (compiled with clang) and then as web assembly in Firefox and Google chrome.\n\n&nbsp; \n\n### Configuration\n\n|           | Version/ Detail                                         |\n| ----------| --------------------------------------------------------|\n| OS        | macOS Big Sur 11.3.1                                    |\n| Hardware  | MacBook Pro (15-inch, 2018) 2.9 GHz 6-Core Intel Core i9|\n| Clang     | Apple clang version 12.0.5 (clang-1205.0.22.9)          |\n| Emcc      | emcc (Emscripten gcc/clang-like replacement) 1.38.30    |\n| Firefox   | 92.0.1 (64-bit)                                         |\n| Chrome    | Version 94.0.4606.71 (Official Build) (x86_64)          |\n\n\n&nbsp; \n\n## Native run\n\nThe native binary was compiled with -O2 optimization flag. The benchmark code was run 5 times and and it took average of **2955** milliseconds. So every shape recognition call took around 2.9 ms\n\n&nbsp; \n\n## Web Assembly run\n\nHere is the result of the web assembly run. The time below is the time taken to execute the above benchmark code while running as web assembly. The percent number is the execution speed relative to the native speed.\n\n\n| Optimization Flag   | No Flag            | -O2               | -Oz              |\n| --------------------| -------------------|-------------------|------------------|\n| Firefox             | 6302 ms (46.88%)   | 19231 ms (15.36%) | 3771 ms (78.36%) |\n| Google Chrome       | 28190 ms (10.48%)  | 4619 ms (63.97%)  | 6746 ms (43.80%) |\n| Binary Size         | 5.44M              | 1.48M             | 1.04M            |\n\n\n&nbsp; \n\nThe fastest speed we could achieve was 78.36% of the native speed while running in Firefox. I guess the Firefox could do even better with the -O2 flag but in this case the Firefox is behaving strangely. I repeated the run many times (with -O2) assuming I made some mistake, but got the same result every time. Probably some temporary issues with Firefox which I think should be fixed in future releases. \n\nBut in general, the Firefox seems to be much more performant than Google chrome in executing the web assembly. \n\n&nbsp; \n\nWe are using the -Oz optimization flag in our build process. With this we get our wasm file of ~1MB. Network transfer (with gzip encoding) is even lesser ~340 KB. This is amazing!!\n\n&nbsp; \n\n## Conclusion\nWeb assembly is quite ready for the production use cases. We tested the Lekh Board on browsers in Android, iOS, Windows, Mac and Linux and it seems all the major browsers on these platforms support web assembly. \n\nFirfox performs much better than Chrome in executing the same web assembly.\n\n&nbsp; \n\n*Please send an email to rajeevk@lekhapp.com if you want to contact the author*\n&nbsp; \n\n\n","layout":"post","updated_at":"Oct 10, 2021","title":"We are using Web Assembly to build Lekh Board","imgwidth":"500px"},"__N_SSG":true}